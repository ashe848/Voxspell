package voxspell;

import java.io.IOException;
import java.util.Queue;

import javax.swing.SwingWorker;

public class Festival {
	private static FestivalSpeed festival_speed=FestivalSpeed.normal;
	private static FestivalVoice festival_voice=FestivalVoice.American;
	private static Voxspell parent_frame;
	private static Festival instance=null;
	private static Queue<FestivalWorker> worker_queue;
	private boolean locked=false;
	private int a = 0;

	public static Festival getInstance(Voxspell parent){
		if (instance==null){
			instance=new Festival(parent);
		}
		return instance;
	}
	
	private Festival(Voxspell parent){
		parent_frame = parent;
	}
	
	public void speak(String speech){
		FestivalWorker worker = new FestivalWorker(speech);
		worker_queue.add(worker);
		if (!locked){
			locked=true;
			worker_queue.poll().execute();
		}
	}
	
	class WorkerQueue {
		
	}

	//class responsible for making the festival calls
//	public synchronized void speak(String speech){
//		//a=1;
//		if (System.getProperty("os.name").equals("Linux")) {
//			//Was Abby's code.
////			SwingWorker<Void, Void> worker = new SwingWorker<Void, Void>() {
////				protected Void doInBackground(){
////					String command = "echo " + speech + "| festival --tts";
//////					parent_frame.getFileIO().writeToScheme(speech, festival_speed, festival_voice);
//////					String command = "festival -b "+parent_frame.getResourceFileLocation()+"festival.scm ; sleep 2";
////					ProcessBuilder pb = new ProcessBuilder("bash", "-c", command);
////					try {
////						Process p = pb.start();
////						p.waitFor(); //waits for the festival call to finish before proceeding as to avoid the speaking overlapping
////					} catch (IOException e){
////						e.printStackTrace();
////					} catch (InterruptedException e) {
////						e.printStackTrace();
////					}
////					return null;
////				}
////				
////				protected void done(){
////					System.out.print("done");
////				}
////			};
//
////			FestivalWorker worker = new FestivalWorker(speech);
//			FestivalWorker worker = FestivalWorker.getInstance(speech);
//			while (worker.locked){
//				try {
//					Thread.sleep(500);
//				} catch (InterruptedException e) {
//					e.printStackTrace();
//				}
//			}
//			worker.execute();
//			
////			worker.work(speech);
//		}
//		else {
//			System.out.println(speech);
//		}
//		//a=2;
////		System.out.println("a");
//	}

	public void setFestivalSpeed(FestivalSpeed speed) {
		festival_speed = speed;
	}

	public void setFestivalVoice(FestivalVoice voice) {
		festival_voice = voice;
	}

	public enum FestivalSpeed {
		slow, normal, fast;

		public double getSpeedValue(){
			switch(this){
			case slow:
				return 1.5;
			case fast:
				return 0.75;
			default:
				return 1.0;
			}
		}
	}
	
	public enum FestivalVoice {
		Kiwi, American;

		public String getVoiceValue(){
			switch(this){
			case Kiwi:
				return "akl_nz_jdt_diphone";
			default:
				return "kal_diphone";
			}
		}
	}
	
	static class FestivalWorker extends SwingWorker<Void, Void>{
		private String speech;
//		private boolean locked=false;
//		private static FestivalWorker instance=null;
//
//		public static FestivalWorker getInstance(String speech){
//			if (instance==null){
//				instance=new FestivalWorker(speech);
//			} else {
//				instance.speech=speech;
//			}
//			return instance;
//		}
		
		private FestivalWorker(String speech){
			this.speech=speech;
		}
		
//		public void work(String speech){
//			this.speech = speech;
//			this.execute();
//		}
		
		protected Void doInBackground(){
			
			//locked=true;
			//System.out.println("lock");

			String command = "echo " + speech + "| festival --tts";
//			parent_frame.getFileIO().writeToScheme(speech, festival_speed, festival_voice);

//			String command = "festival -b "+parent_frame.getResourceFileLocation()+"festival.scm ; sleep 2";
			ProcessBuilder pb = new ProcessBuilder("bash", "-c", command);
			try {
				Process p = pb.start();
				p.waitFor(); //waits for the festival call to finish before proceeding as to avoid the speaking overlapping
			} catch (IOException e){
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			//locked=false;
			//System.out.println("unlock");
			return null;
		}
	}
	
	protected void done(){
		locked=false;
		if (!worker_queue.isEmpty()){
			worker_queue.poll().execute();
		}
		
	}
}
